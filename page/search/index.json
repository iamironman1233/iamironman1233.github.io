[{"content":"(update)\nMISC Discord check hint: \u0026ndash;\u0026gt; flag: WhiteHat{Ready_for_WhiteHatPlay11_Ready_for_a_vibrant_summer} misc04-Audio Ở bài này chúng ta sẽ nhận được 1 file wav (file âm thanh). Ta tiến hành mở file bằng Audacity Chuyển qua xem dưới dạng ảnh phổ ta được: Sử dụng cài đặt ảnh phổ và điều chỉnh thông số sao cho phù hợp, hoặc lăn chuột để phổ giãn đều:\n\u0026ndash;\u0026gt; 3u1b_51_n0dn01 (ở đây vẫn chẳng có nghĩa gì) Xem lại hint của đề bài: A big football team in London Đảo ngược lại cụm ở trên ta được:\n\u0026ndash;\u0026gt; flag: WhiteHat{10nd0n_15_b1u3} ","date":"2022-06-20T00:00:00Z","image":"https://iamironman1233.github.io/post/whitehat-play-11/whitehat_hu7dd45d477e4d529c805ee8af09208680_762750_120x120_fill_box_smart1_3.png","permalink":"https://iamironman1233.github.io/post/whitehat-play-11/","title":"Wargame WhiteHat Play 11"},{"content":"Thu, 09 June 2022, 23:30 SST — Sat, 11 June 2022, 23:30 SST - On-line\nDưới đây là các bài mình đã giải được.\nMISC [Shark1] Ở bài misc đầu tiên, chúng ta nhận được 1 file .pcapng tiến hành mở file bằng wireshark, ta thu được\nMình kiểm tra 1 vài TCP Protocol thì nhận được\nNên mình quyết định follow TCP (Follow \u0026ndash;\u0026gt; TCP Stream)\nVậy là chúng ta sẽ phải biến đổi cụm flag kia thông qua XOR với xor key = 80 Sử dụng trang CyberChef và điền các thông số vào\n\u0026ndash;\u0026gt; flag: accessdenied{w1r3sh4rk_b3st_f0r_p4ck3t_sn1ff1ng_9fc3841b1} [Bobs Favourite Number] Dữ kiện:\nBobs favourite numbers Bob likes two numbers 1856 (as his college was founded as the Civil Engineering College on 24 November 1856) and 2014 (as his college was renamed as Indian Institute of Engineering Science and Technology, Shibpur by the Govt. of India in March 2014). A number N is Bob\u0026rsquo;s favourite number if N is equal to the sum of a certain number of 1856 and sum of a certain number of 2014. Task: Print whether a number is Bob\u0026rsquo;s favourite number or not. Input: First line contains a single integer number N. Output: Print “Yes” if Favourite if N is Bob’s favourite number, else print “No”. Constraints: 1 \u0026lt;= N \u0026lt;= 10^9 Sample input: 5726 Sample output: Yes Sample explanation: 5726 can be represented as the sum of 1856 + 1856 + 2014.\nỞ bài này chúng ta chỉ nên để ý tới 2 số mà Bob thích đó là 1856 và 2014. Ở ví dụ 5726 nhập vào là đúng vì 5726 = 1856 + 1856 + 2014\nNên mình nghĩ nếu nhập 1 số có thể tách ra thành dạng a * 1856 + b * 2014 (a, b \u0026gt;= 1) là sẽ được. Và đề có cho mình server: nc 35.193.60.121 1337 Nên có lẽ các số được input vào sẽ ở trong này. Rất tiếc là server đã đóng nên mình không thể cho ảnh lên writeup được.\nĐể tạo 1 hàm tính xem số được nhập vào có phải dưới dạng a * 1856 + b * 2014 không, thì code rất đơn giản bằng python:\npython Copy def check(n):\rfor i in range(int(n/1856)): #đây là cách nhanh để tạo 1 vòng lặp và thử if(n - (i*1856))%2014 == 0 return True\rreturn False 1 2 3 4 5 def check(n): for i in range(int(n/1856)): #đây là cách nhanh để tạo 1 vòng lặp và thử if(n - (i*1856))%2014 == 0 return True return False và print(check(5726)) thì ta được kết quả là True. Thử kết nối tới server bằng netcat ta được kết quả trả về:\nCopy 168936\rAnswer:168936\rAnswer: Nhập Yes\nCopy Good oneGood one Copy 2512426\rAnswer:2512426\rAnswer: Nhập No\nCopy Wrong AnswerWrong Answer Vậy là khi chúng ta truy cập vào server, nó sẽ đưa chúng ta 1 số và thử, Tiếp theo chúng ta sẽ sử dụng đến Telnet để truy cập vào server của đề và thử các input đó\npython Copy import telnetlib\rtn = telnetlib.Telnet(\u0026#34;35.193.60.121\u0026#34;, 1337) 1 2 import telnetlib tn = telnetlib.Telnet(\u0026#34;35.193.60.121\u0026#34;, 1337) lệnh thử:\npython Copy while(True):\ra = tn.read_until(b\u0026#34;Answer:\u0026#34;)\rif b\u0026#34;Good\u0026#34; in a: num = int(a.split()[2])\relse:\rnum = int(a.split()[0])\rif check(num):\rtn.write(b\u0026#34;Yes\\n\u0026#34;)\relse:\rtn.write(b\u0026#34;No\\n\u0026#34;) 1 2 3 4 5 6 7 8 9 10 while(True): a = tn.read_until(b\u0026#34;Answer:\u0026#34;) if b\u0026#34;Good\u0026#34; in a: num = int(a.split()[2]) else: num = int(a.split()[0]) if check(num): tn.write(b\u0026#34;Yes\\n\u0026#34;) else: tn.write(b\u0026#34;No\\n\u0026#34;) Sau khi chạy xong các test sẽ trả về flag:\n\u0026ndash;\u0026gt; flag: accessdenied{b0bs_f4v0r1t3_4r3_m1n3_f4v0urit3_t00_61c884c8} Crypto [RSA - 1] Ở bài đầu tiên của crypto chúng ta lại gặp 1 dạng quen thuộc đó là giải mã RSA, vì có tới 3 bài loại này cho nên RSA - 1 là dễ hơn hẳn Dữ liệu đề:\nCopy p = 10428615258416108003372202871855627713663325599674460924186517713082197448534315449595394752587304354394402047262801959990727856908043138185588365886987557\rq = 8849030739304056868757301096931487921973840186794195322071503751716059434197468028088264340322992996182734000877348221433845302801843370163430108727308579\re = 65537\rcipher_text = 84826403344972753121997388456739256614537789930909176473018827332005543366933391914385410712984001888365906754988120732970328825657318675360778107518188000885732104031648548997976916964730682864696944786364581243443475767387970255510475855029059715864139791778210784283726274424510221073880200865856769716576p = 10428615258416108003372202871855627713663325599674460924186517713082197448534315449595394752587304354394402047262801959990727856908043138185588365886987557\rq = 8849030739304056868757301096931487921973840186794195322071503751716059434197468028088264340322992996182734000877348221433845302801843370163430108727308579\re = 65537\rcipher_text = 84826403344972753121997388456739256614537789930909176473018827332005543366933391914385410712984001888365906754988120732970328825657318675360778107518188000885732104031648548997976916964730682864696944786364581243443475767387970255510475855029059715864139791778210784283726274424510221073880200865856769716576 Vậy là đề đã cho cả p, q, e và c. Ở đây chúng ta tính ra n bằng cách lấy p * q Tham khảo video của mình về loại bài này ta được code\npython Copy p = 8849030739304056868757301096931487921973840186794195322071503751716059434197468028088264340322992996182734000877348221433845302801843370163430108727308579\rq = 10428615258416108003372202871855627713663325599674460924186517713082197448534315449595394752587304354394402047262801959990727856908043138185588365886987557\rn = p*q\re = 65537\rc = 84826403344972753121997388456739256614537789930909176473018827332005543366933391914385410712984001888365906754988120732970328825657318675360778107518188000885732104031648548997976916964730682864696944786364581243443475767387970255510475855029059715864139791778210784283726274424510221073880200865856769716576\rd1 = (p-1)*(q-1)\rd = pow(e, -1, d1)\rflag = pow(c, d, n)\rprint(flag.to_bytes(47, \u0026#39;big\u0026#39;)) 1 2 3 4 5 6 7 8 9 p = 8849030739304056868757301096931487921973840186794195322071503751716059434197468028088264340322992996182734000877348221433845302801843370163430108727308579 q = 10428615258416108003372202871855627713663325599674460924186517713082197448534315449595394752587304354394402047262801959990727856908043138185588365886987557 n = p*q e = 65537 c = 84826403344972753121997388456739256614537789930909176473018827332005543366933391914385410712984001888365906754988120732970328825657318675360778107518188000885732104031648548997976916964730682864696944786364581243443475767387970255510475855029059715864139791778210784283726274424510221073880200865856769716576 d1 = (p-1)*(q-1) d = pow(e, -1, d1) flag = pow(c, d, n) print(flag.to_bytes(47, \u0026#39;big\u0026#39;)) \u0026ndash;\u0026gt; flag: accessdenied{RSA_1S_4M4Z1nG_R1GhT????_2a5286af} [RSA-3] python Copy N1 = 18266349196400324728796632198426724065863341515460128017379722167088811564142208540762217975696666190887534687486334974478770458134458646785682182438231047535912495200486295399237083743354006572775979196273345894016812147421648391560534928953791045301656072851030393661346227010573392017192092871743599780733618974144278058844414678104713310777338685821340236864598500469843212331330335171804328016140678014295178395686821469446312308097781506852568269309368807576215036130913554259546509277614896420588483929704110258122427731934119749960465772609969329231395097168664992720797902433454838999670183197496533599372453\re1 = 65537\rct1 = 6873813036805706192019236826822502457972771100457517090756917047060847774848540323350759250580238758998913544271128101335276213320240302206398066922772200444602226203653559017733029810367927075606003863202964202725297461799495530697341270915140044964898303984854574497628349362668695378519684693264593494716972185326436905495762497116849607924837994943127697112124217181161062684698865533001086211217060178202980704668203486578672364578669469712587269077695001297138207491663356223994825422557742042083843727850238507161657755737436196961552942941154267260840237025593539923533367161391402240798650010287812581011106\rN2 = 24659767524526013018768938973883991511377669248630968999008468264428208747461052247749924232027616129566843290411914770222062361142014390330463814302544910044772535448949923181736285951382305617780092296934319600643083108399436503551987425616568398265868184384255524744326852580109993750455923648308457300741311644056806840080239266629430170801800674692923486070263947659308964150022391540089059138911526148899685247042835949241530880572488161927637699425020944697998483747469309576045917038431425710502056969197916002745593176785614139365197372746789456581367558816039809574657471032143676431357391125588624599050493\re2 = 65537\rct2 = 11715772208083492702167997175167454009301340692399196360593824415816062365292031273728996255749695189978948242292097965040268601546052250584302206331424224398934005270192769085862845465718216946900897219973683677713043297722976307588263004621450861659350169718646844558379707749844428304916965303036455448719228506667752535085465025614399994834368259311922477097878143154258042140694172977284700008301528490157090476538427961683829505682126281348126157784828204887638985638647829395157101409725453166939388563809584382420835218557337222313577592617066209235421605768519128885685600282422644017925260843832358253267634 1 2 3 4 5 6 7 N1 = 18266349196400324728796632198426724065863341515460128017379722167088811564142208540762217975696666190887534687486334974478770458134458646785682182438231047535912495200486295399237083743354006572775979196273345894016812147421648391560534928953791045301656072851030393661346227010573392017192092871743599780733618974144278058844414678104713310777338685821340236864598500469843212331330335171804328016140678014295178395686821469446312308097781506852568269309368807576215036130913554259546509277614896420588483929704110258122427731934119749960465772609969329231395097168664992720797902433454838999670183197496533599372453 e1 = 65537 ct1 = 6873813036805706192019236826822502457972771100457517090756917047060847774848540323350759250580238758998913544271128101335276213320240302206398066922772200444602226203653559017733029810367927075606003863202964202725297461799495530697341270915140044964898303984854574497628349362668695378519684693264593494716972185326436905495762497116849607924837994943127697112124217181161062684698865533001086211217060178202980704668203486578672364578669469712587269077695001297138207491663356223994825422557742042083843727850238507161657755737436196961552942941154267260840237025593539923533367161391402240798650010287812581011106 N2 = 24659767524526013018768938973883991511377669248630968999008468264428208747461052247749924232027616129566843290411914770222062361142014390330463814302544910044772535448949923181736285951382305617780092296934319600643083108399436503551987425616568398265868184384255524744326852580109993750455923648308457300741311644056806840080239266629430170801800674692923486070263947659308964150022391540089059138911526148899685247042835949241530880572488161927637699425020944697998483747469309576045917038431425710502056969197916002745593176785614139365197372746789456581367558816039809574657471032143676431357391125588624599050493 e2 = 65537 ct2 = 11715772208083492702167997175167454009301340692399196360593824415816062365292031273728996255749695189978948242292097965040268601546052250584302206331424224398934005270192769085862845465718216946900897219973683677713043297722976307588263004621450861659350169718646844558379707749844428304916965303036455448719228506667752535085465025614399994834368259311922477097878143154258042140694172977284700008301528490157090476538427961683829505682126281348126157784828204887638985638647829395157101409725453166939388563809584382420835218557337222313577592617066209235421605768519128885685600282422644017925260843832358253267634 code python:\npython Copy N1 = 18266349196400324728796632198426724065863341515460128017379722167088811564142208540762217975696666190887534687486334974478770458134458646785682182438231047535912495200486295399237083743354006572775979196273345894016812147421648391560534928953791045301656072851030393661346227010573392017192092871743599780733618974144278058844414678104713310777338685821340236864598500469843212331330335171804328016140678014295178395686821469446312308097781506852568269309368807576215036130913554259546509277614896420588483929704110258122427731934119749960465772609969329231395097168664992720797902433454838999670183197496533599372453\re1 = 65537\rct1 = 6873813036805706192019236826822502457972771100457517090756917047060847774848540323350759250580238758998913544271128101335276213320240302206398066922772200444602226203653559017733029810367927075606003863202964202725297461799495530697341270915140044964898303984854574497628349362668695378519684693264593494716972185326436905495762497116849607924837994943127697112124217181161062684698865533001086211217060178202980704668203486578672364578669469712587269077695001297138207491663356223994825422557742042083843727850238507161657755737436196961552942941154267260840237025593539923533367161391402240798650010287812581011106\rN2 = 24659767524526013018768938973883991511377669248630968999008468264428208747461052247749924232027616129566843290411914770222062361142014390330463814302544910044772535448949923181736285951382305617780092296934319600643083108399436503551987425616568398265868184384255524744326852580109993750455923648308457300741311644056806840080239266629430170801800674692923486070263947659308964150022391540089059138911526148899685247042835949241530880572488161927637699425020944697998483747469309576045917038431425710502056969197916002745593176785614139365197372746789456581367558816039809574657471032143676431357391125588624599050493\re2 = 65537\rct2 = 11715772208083492702167997175167454009301340692399196360593824415816062365292031273728996255749695189978948242292097965040268601546052250584302206331424224398934005270192769085862845465718216946900897219973683677713043297722976307588263004621450861659350169718646844558379707749844428304916965303036455448719228506667752535085465025614399994834368259311922477097878143154258042140694172977284700008301528490157090476538427961683829505682126281348126157784828204887638985638647829395157101409725453166939388563809584382420835218557337222313577592617066209235421605768519128885685600282422644017925260843832358253267634\rfrom Crypto.Util.number import inverse, long_to_bytes, bytes_to_long\rfrom gmpy2 import mul,gcd\rdef ProductTree(s):\rl = len(s)\rwhile l \u0026gt; 1:\rif l \u0026amp; 1 != 0:\rs \u0026#43;= [1]\rl \u0026#43;= 1\rs = list(map(mul, s[0 : l \u0026gt;\u0026gt; 1], s[l \u0026gt;\u0026gt; 1 :]))\rl = len(s)\rreturn s[0]\rdef Find_factor(pubs):\rpriv_keys = []\rM = ProductTree(pubs)\rfor i in range(0, len(pubs) - 1):\rpub = pubs[i]\rR = M // pub\rg = gcd(pub, R)\rif pub \u0026gt; g \u0026gt; 1:\rtry:\rp = g\rq = pub // g\rreturn p,q\rexcept Exception as ex:\rprint(ex)\rcontinue\rp1,q1 = Find_factor([N1,N2])\rp2,q2 = Find_factor([N2,N1])\rn1 = p1*q1\rn2 = p2*q2\rphi1 = (p1-1) * (q1-1)\rphi2 = (p2-1) * (q2-1)\rd1 = inverse(e1, phi1)\rd2 = inverse(e2, phi2)\rm1 = pow(ct1, d1, n1)\rm2 = pow(ct2, d2, n2)\rprint(long_to_bytes(m1)\u0026#43;long_to_bytes(m2)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 N1 = 18266349196400324728796632198426724065863341515460128017379722167088811564142208540762217975696666190887534687486334974478770458134458646785682182438231047535912495200486295399237083743354006572775979196273345894016812147421648391560534928953791045301656072851030393661346227010573392017192092871743599780733618974144278058844414678104713310777338685821340236864598500469843212331330335171804328016140678014295178395686821469446312308097781506852568269309368807576215036130913554259546509277614896420588483929704110258122427731934119749960465772609969329231395097168664992720797902433454838999670183197496533599372453 e1 = 65537 ct1 = 6873813036805706192019236826822502457972771100457517090756917047060847774848540323350759250580238758998913544271128101335276213320240302206398066922772200444602226203653559017733029810367927075606003863202964202725297461799495530697341270915140044964898303984854574497628349362668695378519684693264593494716972185326436905495762497116849607924837994943127697112124217181161062684698865533001086211217060178202980704668203486578672364578669469712587269077695001297138207491663356223994825422557742042083843727850238507161657755737436196961552942941154267260840237025593539923533367161391402240798650010287812581011106 N2 = 24659767524526013018768938973883991511377669248630968999008468264428208747461052247749924232027616129566843290411914770222062361142014390330463814302544910044772535448949923181736285951382305617780092296934319600643083108399436503551987425616568398265868184384255524744326852580109993750455923648308457300741311644056806840080239266629430170801800674692923486070263947659308964150022391540089059138911526148899685247042835949241530880572488161927637699425020944697998483747469309576045917038431425710502056969197916002745593176785614139365197372746789456581367558816039809574657471032143676431357391125588624599050493 e2 = 65537 ct2 = 11715772208083492702167997175167454009301340692399196360593824415816062365292031273728996255749695189978948242292097965040268601546052250584302206331424224398934005270192769085862845465718216946900897219973683677713043297722976307588263004621450861659350169718646844558379707749844428304916965303036455448719228506667752535085465025614399994834368259311922477097878143154258042140694172977284700008301528490157090476538427961683829505682126281348126157784828204887638985638647829395157101409725453166939388563809584382420835218557337222313577592617066209235421605768519128885685600282422644017925260843832358253267634 from Crypto.Util.number import inverse, long_to_bytes, bytes_to_long from gmpy2 import mul,gcd def ProductTree(s): l = len(s) while l \u0026gt; 1: if l \u0026amp; 1 != 0: s += [1] l += 1 s = list(map(mul, s[0 : l \u0026gt;\u0026gt; 1], s[l \u0026gt;\u0026gt; 1 :])) l = len(s) return s[0] def Find_factor(pubs): priv_keys = [] M = ProductTree(pubs) for i in range(0, len(pubs) - 1): pub = pubs[i] R = M // pub g = gcd(pub, R) if pub \u0026gt; g \u0026gt; 1: try: p = g q = pub // g return p,q except Exception as ex: print(ex) continue p1,q1 = Find_factor([N1,N2]) p2,q2 = Find_factor([N2,N1]) n1 = p1*q1 n2 = p2*q2 phi1 = (p1-1) * (q1-1) phi2 = (p2-1) * (q2-1) d1 = inverse(e1, phi1) d2 = inverse(e2, phi2) m1 = pow(ct1, d1, n1) m2 = pow(ct2, d2, n2) print(long_to_bytes(m1)+long_to_bytes(m2)) \u0026ndash;\u0026gt; flag: accessdenied{r3us31ng_5tuff_1s_n0t_f0r_crypt0gr4phy_69c36434} REV [babyc] Ở bài này chúng ta sẽ đọc kĩ code và phân tích để đảo ngược lại flag đang được cho nhiễu ban đầu.\nĐọc file rev1.c c Copy #include\u0026lt;stdio.h\u0026gt;\r#include\u0026lt;stdlib.h\u0026gt;\r#include\u0026lt;string.h\u0026gt;\r#define MAXSIZE 100\rchar flag[] = {-111, -47, -47, -79, -39, -39, 49, -79, 97, -127, -79, 49, -55, 9, 27, 89, -19, 59, 97, 49, -19, 89, -37, 121, -37, 89, -69, -37, -19, -111, 89, -37, -19, 113, -71, 97, -19, -101, 49, 49, 11, 91, -69, 11, -79, -87};\rchar reverse(char ch) {\rint x = 0;\rfor(int i = 0; i \u0026lt; 8; i\u0026#43;\u0026#43;) {\rx *= 2;\rif((ch \u0026amp; (1 \u0026lt;\u0026lt; i))) {\rx\u0026#43;\u0026#43;;\r}\r}\rreturn (char)x;\r}\rvoid encode(char str[]) {\rint xor = 23;\rfor(int i = 0; str[i] != \u0026#39;\\0\u0026#39;; i\u0026#43;\u0026#43;) {\rstr[i] = reverse(str[i]);\rstr[i] = (char)(xor ^ str[i]);\r}\r}\rint main()\r{\rchar str[MAXSIZE];\rscanf(\u0026#34;%100s\u0026#34;, str);\rgetchar();\rencode(str);\rif(strcmp(flag, str) == 0){\rprintf(\u0026#34;Access Granted :(\u0026#34;);\r}\relse{\rprintf(\u0026#34;Access Denied :)\u0026#34;);\r}\r} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #define MAXSIZE 100 char flag[] = {-111, -47, -47, -79, -39, -39, 49, -79, 97, -127, -79, 49, -55, 9, 27, 89, -19, 59, 97, 49, -19, 89, -37, 121, -37, 89, -69, -37, -19, -111, 89, -37, -19, 113, -71, 97, -19, -101, 49, 49, 11, 91, -69, 11, -79, -87}; char reverse(char ch) { int x = 0; for(int i = 0; i \u0026lt; 8; i++) { x *= 2; if((ch \u0026amp; (1 \u0026lt;\u0026lt; i))) { x++; } } return (char)x; } void encode(char str[]) { int xor = 23; for(int i = 0; str[i] != \u0026#39;\\0\u0026#39;; i++) { str[i] = reverse(str[i]); str[i] = (char)(xor ^ str[i]); } } int main() { char str[MAXSIZE]; scanf(\u0026#34;%100s\u0026#34;, str); getchar(); encode(str); if(strcmp(flag, str) == 0){ printf(\u0026#34;Access Granted :(\u0026#34;); } else{ printf(\u0026#34;Access Denied :)\u0026#34;); } } có thể thấy từ void reverse ta có 1 phần tử của flag (lấy trường hợp cụ thể là flag[0]) khi chạy qua reverse sẽ tiếp tục chạy thêm vòng lặp gồm 8 loop (0 \u0026ndash;\u0026gt;7) sẽ biến đổi:\nVí dụ a (text) \u0026ndash;\u0026gt; 01100001 (binary) và qua 8 lần so sánh với 00000001 (và các cách dịch chuyển sang trái 1 bit của nó) thì ta được biến x lúc này thành: ( ( ( ( 0 * 2 + 1 )* 2 * 2 * 2 * 2) * 2 + 1) * 2 + 1) * 2 = 134\nvà ngay cuối hàm ta thấy ép kiểu x sang char nên lúc này x mặc định để ta tính là: 10001100.\nTiếp theo từ việc encode flag (ta coi là đang encode 1 phần tử flag[0]) ta thấy rằng trong hàm encode sẽ có reverse (bước trên đã làm) và biến đổi flag[0] lúc này bằng: xr ^ flag[0] (đã được ép kiểu sang char và xr ở đây bằng 23(dec) \u0026ndash;\u0026gt; 00010111(bin))\nChúng ta sẽ tiến hành in thử flag ra thì được: æ╤╤▒┘┘1▒aü▒1╔ φ;a1φY█y█Y╗█φæY█φq╣aφ¢11 [╗ ▒⌐\nMình nghĩ đây là flag đã được biến đổi giống như chúng ta encode và reverse str.\nThật vậy, mình với kinh nghiệm làm bài rsa-1 thì đã biết form của flag là accessdenied{} nên mình thử nhập str là a thêm printf(\u0026quot;%s\u0026quot;, flag) thì đều thu được đầu ra là 2 kí tự giống hệt nhau æ æ.\nmình thử ẩn dòng str[i] = (char)(xr ^ str[i]); dưới comment và thêm thử hàm decode:\ncsharp Copy void decode(char flag[]) {\rint i, xor = 23;\rfor( i = 0; flag[i] != \u0026#39;\\0\u0026#39;; i\u0026#43;\u0026#43;) {\rstr[i] = (char)(xor ^ flag[i]);\r}\r} 1 2 3 4 5 6 void decode(char flag[]) { int i, xor = 23; for( i = 0; flag[i] != \u0026#39;\\0\u0026#39;; i++) { str[i] = (char)(xor ^ flag[i]); } } đến đây flag và str vẫn giống nhau. nên mình nhận ra có điều gì đó chúng ta có thể rút gọn được\nvà mình để ý 1 chút ở số 134 ở bên trên thì đổi ra thành 01100001 và đúng bằng decode(flag[0]) được đảo ngược lại\n:::success :bulb: vậy nên mình nghĩ chỉ cần sử dụng hàm decode(flag) và đảo ngược lại nó là xong :::\nViết lại code (viết lại bằng C) c Copy #include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;stdlib.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rint flag[] = {-111, -47, -47, -79, -39, -39, 49, -79, 97, -127, -79, 49, -55, 9, 27, 89, -19, 59, 97, 49, -19, 89, -37, 121, -37, 89, -69, -37, -19, -111, 89, -37, -19, 113, -71, 97, -19, -101, 49, 49, 11, 91, -69, 11, -79, -87};\rint main()\r{\rint xr = 23, i;\rfor (i = 0; flag[i] != \u0026#39;\\0\u0026#39;; i\u0026#43;\u0026#43;)\r{\rflag[i] = (int)(xr ^ flag[i]);\rif (flag[i] \u0026lt; 0)\rflag[i] = 256 \u0026#43; flag[i];\r//ở đây sẽ không thêm trường hợp của số dương vì mình thử thì thấy thế =))\rprintf(\u0026#34;%d, \u0026#34;, flag[i]);\r}\r} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int flag[] = {-111, -47, -47, -79, -39, -39, 49, -79, 97, -127, -79, 49, -55, 9, 27, 89, -19, 59, 97, 49, -19, 89, -37, 121, -37, 89, -69, -37, -19, -111, 89, -37, -19, 113, -71, 97, -19, -101, 49, 49, 11, 91, -69, 11, -79, -87}; int main() { int xr = 23, i; for (i = 0; flag[i] != \u0026#39;\\0\u0026#39;; i++) { flag[i] = (int)(xr ^ flag[i]); if (flag[i] \u0026lt; 0) flag[i] = 256 + flag[i]; //ở đây sẽ không thêm trường hợp của số dương vì mình thử thì thấy thế =)) printf(\u0026#34;%d, \u0026#34;, flag[i]); } } Kết quả in ra chuỗi các số nhị phân (ở đây có thể hiểu chính là flag dưới dạng nhị phân đã bị đảo ngược)\nKết quả sau khi viết lại chương trình ta thu được dãy các số nguyên được hiểu là sau khi đảo ngược của encode(flag)\nChuyển dãy số về số nhị phân mình sử dụng C++ cho đơn giản, còn nếu bạn nào muốn chạy từng số 1 có thể dùng tool\ncpp Copy #include \u0026lt;iostream\u0026gt;\r#include \u0026lt;stdlib.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\rusing namespace std;\rint flag[] = {134, 198, 198, 166, 206, 206, 38, 166, 118, 150, 166, 38, 222, 30, 12, 78, 250, 44, 118, 38, 250, 78, 204, 110, 204, 78, 172, 204, 250, 134, 78, 204, 250, 102, 174, 118, 250, 140, 38, 38, 28, 76, 172, 28, 166, 190};\rvoid DecimalToBinary(int n) {\rint binaryNumber[100], num=n;\rint i = 0;\rwhile (n \u0026gt; 0) {\rbinaryNumber[i] = n % 2;\rn = n / 2;\ri\u0026#43;\u0026#43;;\r}\rint j;\rfor (j = i - 1; j \u0026gt;= 0; j--)\rcout\u0026lt;\u0026lt;binaryNumber[j];\rcout\u0026lt;\u0026lt;\u0026#34; \u0026#34;;\r}\rint main()\r{\rint i;\rfor (i = 0; i \u0026lt; 46; i\u0026#43;\u0026#43;)\r{\rDecimalToBinary(flag[i]);\r}\r} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; int flag[] = {134, 198, 198, 166, 206, 206, 38, 166, 118, 150, 166, 38, 222, 30, 12, 78, 250, 44, 118, 38, 250, 78, 204, 110, 204, 78, 172, 204, 250, 134, 78, 204, 250, 102, 174, 118, 250, 140, 38, 38, 28, 76, 172, 28, 166, 190}; void DecimalToBinary(int n) { int binaryNumber[100], num=n; int i = 0; while (n \u0026gt; 0) { binaryNumber[i] = n % 2; n = n / 2; i++; } int j; for (j = i - 1; j \u0026gt;= 0; j--) cout\u0026lt;\u0026lt;binaryNumber[j]; cout\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } int main() { int i; for (i = 0; i \u0026lt; 46; i++) { DecimalToBinary(flag[i]); } } Sau khi chuyển dãy trên về số nhị phân ta thu được dãy nhị phân như sau:\nCopy 10000110 11000110 11000110 10100110 11001110 11001110 100110 10100110 1110110 10010110 10100110 100110 11011110 11110 1100 1001110 11111010 101100 1110110 100110 11111010 1001110 11001100 1101110 11001100 1001110 10101100 11001100 11111010 10000110 1001110 11001100 11111010 1100110 10101110 1110110 11111010 10001100 100110 100110 11100 1001100 10101100 11100 10100110 1011111010000110 11000110 11000110 10100110 11001110 11001110 100110 10100110 1110110 10010110 10100110 100110 11011110 11110 1100 1001110 11111010 101100 1110110 100110 11111010 1001110 11001100 1101110 11001100 1001110 10101100 11001100 11111010 10000110 1001110 11001100 11111010 1100110 10101110 1110110 11111010 10001100 100110 100110 11100 1001100 10101100 11100 10100110 10111110 ta để ý thêm cho các số nhị phân sao cho đủ 8 bit để khi đổi chiều lại không bị lỗi\nCode đảo ngược các chuỗi binary để tìm ra flag cpp Copy #include\u0026lt;iostream\u0026gt;\rusing namespace std;\rvoid str_reverse(char str[]) {\rint lo = 0;\rint length;\rfor (length = 0; str[length] != \u0026#39;\\0\u0026#39; ; length\u0026#43;\u0026#43;) {} while ( lo \u0026lt; length ) {\r--length;\rchar tmp = str[lo];\rstr[lo] = str[length];\rstr[length] = tmp;\r\u0026#43;\u0026#43;lo;\r}\r}\rint main() {\rchar str[100];\rint i =100;\rwhile (i \u0026gt; 0) {\rcin \u0026gt;\u0026gt; str;\rstr_reverse(str);\rcout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\ri--;}\rreturn 0;\r} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; using namespace std; void str_reverse(char str[]) { int lo = 0; int length; for (length = 0; str[length] != \u0026#39;\\0\u0026#39; ; length++) {} while ( lo \u0026lt; length ) { --length; char tmp = str[lo]; str[lo] = str[length]; str[length] = tmp; ++lo; } } int main() { char str[100]; int i =100; while (i \u0026gt; 0) { cin \u0026gt;\u0026gt; str; str_reverse(str); cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34; \u0026#34;; i--;} return 0; } Sau khi đã đảo ngược xong, ta thu được dãy\nCopy 01100001 01100011 01100011 01100101 01110011 01110011 01100100 01100101 01101110 01101001 01100101 01100100 01111011 01111000 00110000 01110010 01011111 00110100 01101110 01100100 01011111 01110010 00110011 01110110 00110011 01110010 00110101 00110011 01011111 01100001 01110010 00110011 01011111 01100110 01110101 01101110 01011111 00110001 01100100 01100100 00111000 00110010 00110101 00111000 01100101 0111110101100001 01100011 01100011 01100101 01110011 01110011 01100100 01100101 01101110 01101001 01100101 01100100 01111011 01111000 00110000 01110010 01011111 00110100 01101110 01100100 01011111 01110010 00110011 01110110 00110011 01110010 00110101 00110011 01011111 01100001 01110010 00110011 01011111 01100110 01110101 01101110 01011111 00110001 01100100 01100100 00111000 00110010 00110101 00111000 01100101 01111101 Sử dụng trang web này để xử lý nốt phần còn lại và thu được flag.\n\u0026mdash;\u0026gt; flag: accessdenied{x0r_4nd_r3v3r53_ar3_fun_1dd8258e} Trên đó là cách giải chay như lúc mình nghĩ ra, còn khi vào làm thực sự thì chúng ta chỉ cần sử dụng việc giải ngược lại của flag là done. Code để đảo ngược:\nc Copy for(i = 0; i \u0026lt;46;i\u0026#43;\u0026#43;){\rchar c = flag[i];\rprintf(\u0026#34;%c\u0026#34;, reverse(23 ^ flag[i]));\r} 1 2 3 4 for(i = 0; i \u0026lt;46;i++){ char c = flag[i]; printf(\u0026#34;%c\u0026#34;, reverse(23 ^ flag[i])); } full code:\nc Copy #include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;stdlib.h\u0026gt;\r#include \u0026lt;string.h\u0026gt;\r#define MAXSIZE 100\rchar flag[] = {-111, -47, -47, -79, -39, -39, 49, -79, 97, -127, -79, 49, -55, 9, 27, 89, -19, 59, 97, 49, -19, 89, -37, 121, -37, 89, -69, -37, -19, -111, 89, -37, -19, 113, -71, 97, -19, -101, 49, 49, 11, 91, -69, 11, -79, -87};\rchar reverse(char ch)\r{\rint x = 0, i;\rfor (i = 0; i \u0026lt; 8; i\u0026#43;\u0026#43;)\r{\rx *= 2;\rif ((ch \u0026amp; (1 \u0026lt;\u0026lt; i)))\r{\rx\u0026#43;\u0026#43;;\r}\r}\rreturn (char)x;\r}\rvoid encode(char str[])\r{\rint xr = 23, i;\rfor (i = 0; str[i] != \u0026#39;\\0\u0026#39;; i\u0026#43;\u0026#43;)\r{\rstr[i] = reverse(str[i]);\r}\r}\rint main()\r{\rchar str[MAXSIZE];\rint i;\rfor (i = 0; i \u0026lt; 46; i\u0026#43;\u0026#43;)\r{\rchar c = flag[i];\rprintf(\u0026#34;%c\u0026#34;, reverse(23 ^ flag[i]));\r}\rgetchar();\rprintf(\u0026#34;%s\u0026#34;, flag);\r} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MAXSIZE 100 char flag[] = {-111, -47, -47, -79, -39, -39, 49, -79, 97, -127, -79, 49, -55, 9, 27, 89, -19, 59, 97, 49, -19, 89, -37, 121, -37, 89, -69, -37, -19, -111, 89, -37, -19, 113, -71, 97, -19, -101, 49, 49, 11, 91, -69, 11, -79, -87}; char reverse(char ch) { int x = 0, i; for (i = 0; i \u0026lt; 8; i++) { x *= 2; if ((ch \u0026amp; (1 \u0026lt;\u0026lt; i))) { x++; } } return (char)x; } void encode(char str[]) { int xr = 23, i; for (i = 0; str[i] != \u0026#39;\\0\u0026#39;; i++) { str[i] = reverse(str[i]); } } int main() { char str[MAXSIZE]; int i; for (i = 0; i \u0026lt; 46; i++) { char c = flag[i]; printf(\u0026#34;%c\u0026#34;, reverse(23 ^ flag[i])); } getchar(); printf(\u0026#34;%s\u0026#34;, flag); } Update (Sau khi kết thúc giải) Sau khi tham khảo về sự khả thi của python thì mình thấy viết lại bằng python nhẹ hơn rất nhiều, dưới đây là code python của bạn zebruh:\npython Copy flag = [-111, -47, -47, -79, -39, -39, 49, -79, 97, -127, -79, 49, -55, 9, 27, 89, -19, 59, 97, 49, -19, 89, -37, 121, -37, 89, -69, -37, -19, -111, 89, -37, -19, 113, -71, 97, -19, -101, 49, 49, 11, 91, -69, 11, -79, -87]\ra=[0 for i in range(46)]\rb=[0 for i in range(46)]\rc=[0 for i in range(46)]\rdef one():\rfor i in range(0,len(flag),1):\rflag[i] = 23 ^ flag[i]\rif (flag[i] \u0026lt; 0):\rflag[i] = 256 \u0026#43; flag[i]\ra[i] = flag[i]\rone()\rdef to_bin():\rfor i in range (0,len(a),1):\rb[i]=\u0026#39;{0:08b}\u0026#39;.format(a[i])\rto_bin()\rfor i in range (0,len(b),1):\rc[i]=b[i][::-1]\rprint(c[i]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 flag = [-111, -47, -47, -79, -39, -39, 49, -79, 97, -127, -79, 49, -55, 9, 27, 89, -19, 59, 97, 49, -19, 89, -37, 121, -37, 89, -69, -37, -19, -111, 89, -37, -19, 113, -71, 97, -19, -101, 49, 49, 11, 91, -69, 11, -79, -87] a=[0 for i in range(46)] b=[0 for i in range(46)] c=[0 for i in range(46)] def one(): for i in range(0,len(flag),1): flag[i] = 23 ^ flag[i] if (flag[i] \u0026lt; 0): flag[i] = 256 + flag[i] a[i] = flag[i] one() def to_bin(): for i in range (0,len(a),1): b[i]=\u0026#39;{0:08b}\u0026#39;.format(a[i]) to_bin() for i in range (0,len(b),1): c[i]=b[i][::-1] print(c[i]) Cả 2 đều có điểm chung là cùng một phương pháp, cùng tạo ra chuỗi nhị phân cuối cùng:\nCopy 01100001 01100011 01100011 01100101 01110011 01110011 01100100 01100101 01101110 01101001 01100101 01100100 01111011 01111000 00110000 01110010 01011111 00110100 01101110 01100100 01011111 01110010 00110011 01110110 00110011 01110010 00110101 00110011 01011111 01100001 01110010 00110011 01011111 01100110 01110101 01101110 01011111 00110001 01100100 01100100 00111000 00110010 00110101 00111000 01100101 0111110101100001 01100011 01100011 01100101 01110011 01110011 01100100 01100101 01101110 01101001 01100101 01100100 01111011 01111000 00110000 01110010 01011111 00110100 01101110 01100100 01011111 01110010 00110011 01110110 00110011 01110010 00110101 00110011 01011111 01100001 01110010 00110011 01011111 01100110 01110101 01101110 01011111 00110001 01100100 01100100 00111000 00110010 00110101 00111000 01100101 01111101 và cùng phải nhờ sự trợ giúp của tool để chuyển đổi nốt sang text 1 cách nhanh chóng, nhưng về mặt tốc độ thì python là hơn hẳn.\n[Bits are Fun] Làm tương tự như bài rev1 và tham khảo thêm về hàm strncmp ta được code như sau:\nc Copy #include\u0026lt;stdio.h\u0026gt;\r#include\u0026lt;stdlib.h\u0026gt;\r#include\u0026lt;string.h\u0026gt;\r#define MAXSIZE 100\rchar flag[] = {105, 97, 103, 115, 113, 102, 103, 100, 97, 111, 108, 113, 100, 59, 108, 118, 119, 112, 26, 118, 52, 116, 49, 117, 54, 78, 100, 127, 112, 27, 103, 96, 118, 125, 112, 26, 118, 52, 116, 49, 53, 119, 52, 90, 49, 119, 98, 30, 120, 100, 119, 53, 75, 52, 49, 97, 102, 103, 54, 117, 97};\rchar *left_rotate_and_right_rotate(char str[]) {\rint i, len = strlen(str);\rfor(i = 0; i \u0026lt; 8; i\u0026#43;\u0026#43;) {\rif((i \u0026amp; 1)) {\rint j, store = ((((1 \u0026lt;\u0026lt; i) \u0026amp; str[len - 1]) \u0026gt; 0) ? 1 : 0);\rfor(j = len - 2; j \u0026gt;= 0; j--) {\rint bit = ((((1 \u0026lt;\u0026lt; i) \u0026amp; str[j]) \u0026gt; 0) ? 1 : 0);\rstr[j \u0026#43; 1] \u0026amp;= (~(1 \u0026lt;\u0026lt; i));\rstr[j \u0026#43; 1] |= (1 \u0026lt;\u0026lt; i) * bit;\r}\rstr[0] \u0026amp;= (~(1 \u0026lt;\u0026lt; i));\rstr[0] |= (1 \u0026lt;\u0026lt; i) * store;\r}\relse {\rint j, store = ((((1 \u0026lt;\u0026lt; i) \u0026amp; str[0]) \u0026gt; 0) ? 1 : 0);\rfor(j = 1; j \u0026lt; len; j\u0026#43;\u0026#43;) {\rint bit = ((((1 \u0026lt;\u0026lt; i) \u0026amp; str[j]) \u0026gt; 0) ? 1 : 0);\rstr[j - 1] \u0026amp;= (~(1 \u0026lt;\u0026lt; i));\rstr[j - 1] |= (1 \u0026lt;\u0026lt; i) * bit;\r}\rstr[len - 1] \u0026amp;= (~(1 \u0026lt;\u0026lt; i));\rstr[len - 1] |= (1 \u0026lt;\u0026lt; i) * store;\r}\r}\rreturn(str);\r}\rint main()\r{\rchar *tmp;\rint i;\rfor(i = 0; i \u0026lt; 1000; i\u0026#43;\u0026#43;)\r{\rtmp = left_rotate_and_right_rotate(flag);\rif(strncmp(tmp,\u0026#34;accessdenied\u0026#34;,12) == 0)\r{\rprintf(\u0026#34;%s\\n\u0026#34;,tmp);\rreturn(1);\r}\r}\rreturn 0;\r} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #define MAXSIZE 100 char flag[] = {105, 97, 103, 115, 113, 102, 103, 100, 97, 111, 108, 113, 100, 59, 108, 118, 119, 112, 26, 118, 52, 116, 49, 117, 54, 78, 100, 127, 112, 27, 103, 96, 118, 125, 112, 26, 118, 52, 116, 49, 53, 119, 52, 90, 49, 119, 98, 30, 120, 100, 119, 53, 75, 52, 49, 97, 102, 103, 54, 117, 97}; char *left_rotate_and_right_rotate(char str[]) { int i, len = strlen(str); for(i = 0; i \u0026lt; 8; i++) { if((i \u0026amp; 1)) { int j, store = ((((1 \u0026lt;\u0026lt; i) \u0026amp; str[len - 1]) \u0026gt; 0) ? 1 : 0); for(j = len - 2; j \u0026gt;= 0; j--) { int bit = ((((1 \u0026lt;\u0026lt; i) \u0026amp; str[j]) \u0026gt; 0) ? 1 : 0); str[j + 1] \u0026amp;= (~(1 \u0026lt;\u0026lt; i)); str[j + 1] |= (1 \u0026lt;\u0026lt; i) * bit; } str[0] \u0026amp;= (~(1 \u0026lt;\u0026lt; i)); str[0] |= (1 \u0026lt;\u0026lt; i) * store; } else { int j, store = ((((1 \u0026lt;\u0026lt; i) \u0026amp; str[0]) \u0026gt; 0) ? 1 : 0); for(j = 1; j \u0026lt; len; j++) { int bit = ((((1 \u0026lt;\u0026lt; i) \u0026amp; str[j]) \u0026gt; 0) ? 1 : 0); str[j - 1] \u0026amp;= (~(1 \u0026lt;\u0026lt; i)); str[j - 1] |= (1 \u0026lt;\u0026lt; i) * bit; } str[len - 1] \u0026amp;= (~(1 \u0026lt;\u0026lt; i)); str[len - 1] |= (1 \u0026lt;\u0026lt; i) * store; } } return(str); } int main() { char *tmp; int i; for(i = 0; i \u0026lt; 1000; i++) { tmp = left_rotate_and_right_rotate(flag); if(strncmp(tmp,\u0026#34;accessdenied\u0026#34;,12) == 0) { printf(\u0026#34;%s\\n\u0026#34;,tmp); return(1); } } return 0; } \u0026ndash;\u0026gt; flag: accessdenied{l3ft_r0t4t3_4nd_r1ght_r0t4t35_4r3_h4rd_5a43cfe4} [enormous] Ở bài này thì đơn giản ở chỗ (hoặc là mình bị lừa vì mình không test flag được) chúng ta sử dụng IDA (bản nào cũng được nhưng phải là bản thích hợp :\u0026gt;) để tìm ra flag 1 cách dễ dàng.\nCheck function trong IDA Dễ thấy trong mục function không có main nên mình cũng hơi mông lung 1 chút trong việc suy nghĩ liệu hàm main có bị ẩn đi hay không và nếu ẩn đi thì làm thế nào để mở được.\nQuay lại đề bài 1 chút, để ý rằng đề bài có nhắc đến see the number\nLúc đầu mình cũng không để ý lắm tới khi sử dụng lệnh strings enormous và hiện ra 1 loạt các dòng số và chữ\nnên mình để ý tới các function ngay bên dưới có chứa các kí tự gồm số và chữ cái\nKhi nhấn vào function đầu tiên thì hiện ra graph overview như sau:\nvà với 1 người chơi hệ tâm linh như mình thì mình cảm nhận chữ a này hơi quen, hình như nó ở format của flag thì phải accessdenied{}\nmình tiếp tục xem các function tiếp theo lần lượt hiện c, c, e, s, s, \u0026hellip; nên mình chắc ăn đây là flag và hoàn toàn chúng ta có thể chạy từng function một để ghép lại thành flag hoàn chỉnh\nSau quá trình gian nan, thì mình ghép lại được cụm flag là:\n\u0026ndash;\u0026gt; **flag: accessdenied{US3_AngR_F0RM4klnG_Lif3_B3Tt3R_57a27836} ** ","date":"2022-06-17T00:00:00Z","image":"https://iamironman1233.github.io/post/access-denined-ctf-2022/logo_hu6de0a265f2ab805fd9eca1b4b2c1a5cb_326546_120x120_fill_box_smart1_3.png","permalink":"https://iamironman1233.github.io/post/access-denined-ctf-2022/","title":"Access Denied CTF 2022"},{"content":"Dưới đây là list các bài thực hành tin đại cương (sẽ được update)\nBài thực hành số 2 - Tin đại cương Bài 2.01 c Copy #include\u0026lt;stdio.h\u0026gt;\rint main(){\rfloat a, b, tong;\rscanf(\u0026#34;%f\u0026#34;, \u0026amp;a);\rscanf(\u0026#34;%f\u0026#34;, \u0026amp;b);\rtong=a\u0026#43;b;\rprintf(\u0026#34;%f\u0026#34;, tong);\rreturn 0;\r} 1 2 3 4 5 6 7 8 9 #include\u0026lt;stdio.h\u0026gt; int main(){ float a, b, tong; scanf(\u0026#34;%f\u0026#34;, \u0026amp;a); scanf(\u0026#34;%f\u0026#34;, \u0026amp;b); tong=a+b; printf(\u0026#34;%f\u0026#34;, tong); return 0; } Bài 2.02 c Copy #include\u0026lt;stdio.h\u0026gt;\rint main()\r{\rfloat a, b, max;\rscanf(\u0026#34;%f\u0026#34;, \u0026amp;a);\rscanf(\u0026#34;%f\u0026#34;, \u0026amp;b);\rmax=a;\rif (max \u0026lt;b)\rmax = b;\rprintf(\u0026#34;%6.2f\u0026#34;, max);\rreturn 0;\r} 1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int main() { float a, b, max; scanf(\u0026#34;%f\u0026#34;, \u0026amp;a); scanf(\u0026#34;%f\u0026#34;, \u0026amp;b); max=a; if (max \u0026lt;b) max = b; printf(\u0026#34;%6.2f\u0026#34;, max); return 0; } Bài 2.03 code:\nc Copy #include\u0026lt;stdio.h\u0026gt;\rint main()\r{\rfloat x, y, min;\rscanf(\u0026#34;%f\u0026#34;, \u0026amp;x);\rscanf(\u0026#34;%f\u0026#34;, \u0026amp;y);\rif (x\u0026lt;y)\rmin = x;\relse min = y;\rprintf(\u0026#34;%.2f\u0026#34;, min);\rreturn 0;\r} 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int main() { float x, y, min; scanf(\u0026#34;%f\u0026#34;, \u0026amp;x); scanf(\u0026#34;%f\u0026#34;, \u0026amp;y); if (x\u0026lt;y) min = x; else min = y; printf(\u0026#34;%.2f\u0026#34;, min); return 0; } Bài 2.04 code:\nc Copy #include\u0026lt;stdio.h\u0026gt;\rint main()\r{\rfloat x, y, max;\rscanf(\u0026#34;%f\u0026#34;, \u0026amp;x);\rscanf(\u0026#34;%f\u0026#34;, \u0026amp;y);\rif (x\u0026gt;y)\rmax = x;\relse max = y;\rprintf(\u0026#34;%6.2f\u0026#34;,max);\rreturn 0;\r} 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int main() { float x, y, max; scanf(\u0026#34;%f\u0026#34;, \u0026amp;x); scanf(\u0026#34;%f\u0026#34;, \u0026amp;y); if (x\u0026gt;y) max = x; else max = y; printf(\u0026#34;%6.2f\u0026#34;,max); return 0; } Bài 2.05 code:\nc Copy #include\u0026lt;stdio.h\u0026gt;\rint main()\r{\rint a, b, c, tong;\rscanf(\u0026#34;%d\u0026#34;, \u0026amp;a);\rscanf(\u0026#34;%d\u0026#34;, \u0026amp;b);\rscanf(\u0026#34;%d\u0026#34;, \u0026amp;c);\rtong=a\u0026#43;b\u0026#43;c;\rprintf(\u0026#34;%d\\n\u0026#34;, tong);\rprintf(\u0026#34;%f\u0026#34;, tong/3.0);\r} 1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;stdio.h\u0026gt; int main() { int a, b, c, tong; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); scanf(\u0026#34;%d\u0026#34;, \u0026amp;b); scanf(\u0026#34;%d\u0026#34;, \u0026amp;c); tong=a+b+c; printf(\u0026#34;%d\\n\u0026#34;, tong); printf(\u0026#34;%f\u0026#34;, tong/3.0); } Bài thực hành tin đại cương số 3 Bài 3.01 c Copy #include \u0026lt;stdio.h\u0026gt;\rint main()\r{\rdouble toan, ly, hoa, tong;\rscanf(\u0026#34;%lf%lf%lf\u0026#34;, \u0026amp;toan, \u0026amp;ly, \u0026amp;hoa);\rtong = toan \u0026#43; ly \u0026#43; hoa;\rprintf(\u0026#34;%lf\\n%lf\u0026#34;, tong, tong/3.0);\rreturn 0;\r} 1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main() { double toan, ly, hoa, tong; scanf(\u0026#34;%lf%lf%lf\u0026#34;, \u0026amp;toan, \u0026amp;ly, \u0026amp;hoa); tong = toan + ly + hoa; printf(\u0026#34;%lf\\n%lf\u0026#34;, tong, tong/3.0); return 0; } Bài 3.02 c Copy #include \u0026lt;stdio.h\u0026gt;\r#define p 3.14159\rint main() {\rdouble r, M, S;\rscanf(\u0026#34;%lf\u0026#34;, \u0026amp;r);\rif (r \u0026lt;= 0)\rprintf(\u0026#34;ERROR\u0026#34;);\relse {\rM = 2 * p * r;\rS = p * r * r;\rprintf(\u0026#34;%lf\\n%lf\u0026#34;, M, S);\r}\rreturn 0;\r} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #define p 3.14159 int main() { double r, M, S; scanf(\u0026#34;%lf\u0026#34;, \u0026amp;r); if (r \u0026lt;= 0) printf(\u0026#34;ERROR\u0026#34;); else { M = 2 * p * r; S = p * r * r; printf(\u0026#34;%lf\\n%lf\u0026#34;, M, S); } return 0; } Bài 3.03 c Copy #include \u0026lt;stdio.h\u0026gt;\rint main()\r{\rdouble x, y, a, b, c;\rscanf(\u0026#34;%lf%lf\u0026#34;, \u0026amp;x, \u0026amp;y);\ra = x * x \u0026#43; y * y;\rb = (x \u0026#43; y) * (x \u0026#43; y);\rc = (x - y) * (x - y);\rprintf(\u0026#34;%lf\\n%lf\\n%lf\u0026#34;, a, b, c);\rreturn 0;\r} 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { double x, y, a, b, c; scanf(\u0026#34;%lf%lf\u0026#34;, \u0026amp;x, \u0026amp;y); a = x * x + y * y; b = (x + y) * (x + y); c = (x - y) * (x - y); printf(\u0026#34;%lf\\n%lf\\n%lf\u0026#34;, a, b, c); return 0; } Bài 3.04 c Copy #include \u0026lt;stdio.h\u0026gt;\rint main()\r{\rfloat gkt, cn, t;\rscanf(\u0026#34;%f%f%f\u0026#34;, \u0026amp;gkt, \u0026amp;cn, \u0026amp;t);\rprintf(\u0026#34;%f\u0026#34;, gkt*cn \u0026#43; gkt*cn*t/100.0);\rreturn 0;\r} 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { float gkt, cn, t; scanf(\u0026#34;%f%f%f\u0026#34;, \u0026amp;gkt, \u0026amp;cn, \u0026amp;t); printf(\u0026#34;%f\u0026#34;, gkt*cn + gkt*cn*t/100.0); return 0; } Bài 3.05 c Copy #include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;math.h\u0026gt;\rint main()\r{\rdouble x, y, z, ketqua, a;\rscanf(\u0026#34;%lf%lf%lf\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z);\ra = z * cos(y);\rif (x \u0026gt;= a)\rketqua = ((x \u0026#43; y \u0026#43; z) / (x * x \u0026#43; y * y \u0026#43; 1)) - (x - (z * cos(y)));\relse\rketqua = ((x \u0026#43; y \u0026#43; z) / (x * x \u0026#43; y * y \u0026#43; 1)) - ((z * cos(y)) - x);\rprintf(\u0026#34;%lf\u0026#34;, ketqua);\rreturn 0;\r} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main() { double x, y, z, ketqua, a; scanf(\u0026#34;%lf%lf%lf\u0026#34;, \u0026amp;x, \u0026amp;y, \u0026amp;z); a = z * cos(y); if (x \u0026gt;= a) ketqua = ((x + y + z) / (x * x + y * y + 1)) - (x - (z * cos(y))); else ketqua = ((x + y + z) / (x * x + y * y + 1)) - ((z * cos(y)) - x); printf(\u0026#34;%lf\u0026#34;, ketqua); return 0; } Bài 3.06 c Copy #include \u0026lt;stdio.h\u0026gt;\r#include \u0026lt;math.h\u0026gt;\rint main ()\r{\rdouble x,y,F; //Khai bao cac bien\rscanf(\u0026#34;%lf\u0026#34;,\u0026amp;x);//Nhap x\rscanf(\u0026#34;%lf\u0026#34;,\u0026amp;y);//Nhap y\r//F=Y^6\u0026#43;X×Y^5\u0026#43;X^2×Y^4\u0026#43;X^3×Y^3\u0026#43;X^4×Y^2\u0026#43;X^5×Y\u0026#43;X^6\rF=pow(y,6)\u0026#43;x*pow(y,5)\u0026#43;pow(x,2)*pow(y,4)\u0026#43;pow(x,3)*pow(y,3)\u0026#43;pow(x,4)*pow(y,2)\u0026#43;pow(x,5)*y\u0026#43;pow(x,6);\rprintf(\u0026#34;%6lf\u0026#34;,F);//In ra gia tri F\r} 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;math.h\u0026gt; int main () { double x,y,F; //Khai bao cac bien scanf(\u0026#34;%lf\u0026#34;,\u0026amp;x);//Nhap x scanf(\u0026#34;%lf\u0026#34;,\u0026amp;y);//Nhap y //F=Y^6+X×Y^5+X^2×Y^4+X^3×Y^3+X^4×Y^2+X^5×Y+X^6 F=pow(y,6)+x*pow(y,5)+pow(x,2)*pow(y,4)+pow(x,3)*pow(y,3)+pow(x,4)*pow(y,2)+pow(x,5)*y+pow(x,6); printf(\u0026#34;%6lf\u0026#34;,F);//In ra gia tri F } ","date":"2022-06-15T00:00:00Z","image":"https://iamironman1233.github.io/post/tinhocdaicuong/logo1_huc345b4c6af35e7c6a7529551ca752ecf_30185_120x120_fill_box_smart1_3.png","permalink":"https://iamironman1233.github.io/post/tinhocdaicuong/","title":"Giải bài tập tin học đại cương "}]